<!DOCTYPE HTML>
<html>
  <head>
    <title>Initital workflow proposal</title>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="http://d3js.org/d3.v2.js"></script>
    <!-- <script src="http://talos.github.com/jquery-svgpan/jquery-svgpan.min.js"></script> -->
    <script src="jquery-svgpan.js"></script>


    <style type="text/css">
      body {
        font-family: Helvetica, sans-serif;
      }

      svg {
        border: 1px solid #aaa;
        overflow: hidden; /* Thanks IE9! */
      }

      a:link {
        color: #aaa;
      }

      a:visited {
        color: #aaa;
      }

div { margin-top: 0.5em; margin-right: 0.5em; margin-bottom: 0.5em; margin-left: 0.5em; padding-top: 0.5em; padding-right: 0.5em; padding-bottom: 0.5em; padding-left: 0.5em; }

div#mouse { display: none; position: absolute; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: white; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: black; border-right-color: black; border-bottom-color: black; border-left-color: black; border-image: initial; background-position: initial initial; background-repeat: initial initial; }

div#visuals { float: left; }

div#request { position: absolute; top: 1em; right: 1em; width: 200px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(153, 153, 153); border-right-color: rgb(153, 153, 153); border-bottom-color: rgb(153, 153, 153); border-left-color: rgb(153, 153, 153); border-image: initial; }

textarea { width: 100%; height: 8em; }

      #description {
        float: right;
      }

      svg .role:hove {
         opacity: 0.5;
      }

      svg .action:hover {
         opacity: 0.5;
      }

      svg .condition:hover {
         opacity: 0.5;
      }

    </style>
  </head>

  <body>
    <div id="description"></div>
    <div id="flowchart"></div>

    <script type="text/javascript">
      var description = {
        packagedevel: "<h1>Package Development</h1><ul><li><strong>Type:</strong> Starting Point. Action</li><li><strong>Role:</strong> Package Maintainer</li></ul><p>A package is usually developed in a Home Project. We can consider that this is the starting poing for this workflow.</p><p>With OBS a contributor can make a local branch (usually from a Devel Project) of the package to start working on it. Once the developer finish with the package, he needs to create a Submit Request before he can send it to the corresponding Devel Project.</p>How package are being developed. They start in home project, move from there to devel project and from there to Factory.</p>",

        createsr: "<h1>Create Submit Request</h1><ul><li><strong>Type:</strong>Action</li><li><strong>Role:</strong> Package Maintainer</li></ul><p>A Submit Request is a formal petition of integration from one project to another. This object also capture all the changes made in the package, with all the meta information related with this petition (history of approvals, current status, etc).</p>",

        acceptsr: "<h1>Accept Submit Request</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>The Project Maintainer can decide to accept or reject the SR according to technical decisions.</p>",

        develprojectint: "<h1>Devel Project Integration</h1><ul><li><strong>Type:</strong> Starting Point. Action</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>The process of merging all packages together in a single tree, creating a consistent whole.</p>",

        createsrfactory: "<h1>Create SR to Factory</h1><ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>Create the SR (or group of SR) to be integrated into Factory </p>",

        autolegal: "<h1>Auto Legal</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Legal Reviewer (Bot)</li></ul><p>The boot osc-legal.py check if the package referenced in the SR had a compatible license or if this package was previously approved. If none of these conditions are meet, the bot can reject the SR and wait for a manual review later in the process.</p>",

        rpmlint: "<h1>rpmlint</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Security Reviewer (Bot)</li></ul><p>Attached to the submit process, there is a bot that check the basic security conditions of the package, like SUID permissions.</p>",

        checkrepo: "<h1>Repo Checker</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Technical Reviewer (Bot)</li></ul><p>There is a automatic technical review process for every new SR to Factory. This review look for potential problems before the integration, like expanding the Base:System, disabled repositories, new version of the packages or introducing cycles in the dependencies</p>",

        needsstaging: "<h1>Needs Staging</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Technical Reviewer</li></ul><p>Some packages (or groups of packages) need more effort to be integrated into Factory. For example, a new update of GCC can demand some work to another packages that do not compile using the new compiler without modification.</p><p>For those packages is a good idea 'fork' Factory, integrating an initial version of the new package together with the all affected packages. Now the developers can work on the integration of all those components. This is the main reason of the staging project.</p><p>But someone needs to make a decision about the kind of projects that needs a staging project, because the creation of a staging project from scratch is expensive. To avoid the waste of resources we will create a pool of staging projects that need to be assigned and prepared by the Technical Reviewer. In case of necessity the Factory Maintainer can create new staging projects.</p>",

        stagingprojectint: "<h1>Staging Project Integration</h1><ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>How are requests being managed in staging project.</p><p>They start as a sumbission to factory that is deemed to require new staging project creation or that they are part of already existing request.</p><p>They are then being developed on specific branch of openSUSE:Factory where the designated maintainer with package maintainers fix the issues to have everything working just fine.</p><p>Whenever the developers see fit they can sent the staging changes back to devel projects.</p><p>When the packages are seemingly fine the staging project gets dismantled and all requests in group get forwarded further on in review cycle for Factory submissions.</p>",

        createsrgroup: "<h1>Create SR Groups</h1><ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>How are requests being managed in staging project.</p><p>They start as a sumbission to factory that is deemed to require new staging project creation or that they are part of already existing request.</p><p>They are then being developed on specific branch of openSUSE:Factory where the designated maintainer with package maintainers fix the issues to have everything working just fine.</p><p>Whenever the developers see fit they can sent the staging changes back to devel projects.</p><p>When the packages are seemingly fine the staging project gets dismantled and all requests in group get forwarded further on in review cycle for Factory submissions.</p>",

        mergedevel: "<h1>Merge in Devel Project</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>How are requests being managed in staging project.</p><p>They start as a sumbission to factory that is deemed to require new staging project creation or that they are part of already existing request.</p><p>They are then being developed on specific branch of openSUSE:Factory where the designated maintainer with package maintainers fix the issues to have everything working just fine.</p><p>Whenever the developers see fit they can sent the staging changes back to devel projects.</p><p>When the packages are seemingly fine the staging project gets dismantled and all requests in group get forwarded further on in review cycle for Factory submissions.</p>",

        needsqa: "<h1>Needs QA</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Technical Reviewer</li></ul><p>There are some packages, like the GNU/Linux kernel, that are good candidates for automatic testing before the integration into Factory. Good candidates are packages that can put the system in a very unreliable situation (for example, they can't boot anymore or can disable the access to the network).</p><p>In this task the Technical Reviewer need to identify such packages in order to demand a pre integration test from the QA Team.</p>",

        preinttest: "<h1>Pre Integration Test</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> QA Team</li></ul><p>Process to check whether is safe enough to integrate a set of changes into Factory.</p>",

        legalreview: "<h1>Legal Review</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Legal Reviewer</li></ul>",

        rpmlint2: "<h1>rpmlint</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Security Reviewer</li></ul><p>Attached to the submit process, there is a bot that check the basic security conditions of the package, like SUID permissions. If there is any problem, the Security Reviewer can help to the developer to review manually the package and provide advice to fix the potential security issue.</p>",

        technicalrev: "<h1>Technical Review</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Technical Reviewer</li></ul>",

        acceptsr2: "<h1>Accept Submit Request</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Factory Maintainer</li></ul><p>The process of merging all packages together in a single tree, creating a consistent whole.</p>",

        factoryint: "<h1>Factory Integration</h1><ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Factory Maintainer</li></ul><p>Continuous process to ensure that Factory is solid enough to be used in a daily basis by contributors and for creating Factory-Tested and the ISOs.</p>",

        integrationtest: "<h1>Integration Test</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> QA Team</li></ul><p>Integration tests are done by QA Team when a new SR is integrated in Factory and need to be tested before pass to Factory-Tested. When the Factory Maintainer integrates a new SR, there is a good possibility that some part of the system stop working. The Integration Test is designed to assure that the integration of a new package doesn't affect the functionality of a different package in a unnoticed way.</p><p>To provide this, QA Team will run a set of transversal tests along the full distribution, to make sure that the system work in a similar way previous the integration step.</p><p>This task also decides if the new SR that comes from Factory go to the next step until Factory-Tested. If QA Team detect an important issue related with the new SR, they can decline the copy of the new package (or group of packages) to Factory-Tested.</p>",

        bugreport: "<h1>Bug Report</h1><ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> QA Team</li></ul><p>The Integration Test task can detect errors in the distribution, and as a result of that QA Team needs to fill a bug report. This bug report needs to be precise and detailed to make easy the work for the developer.</p><p>Sometimes the bug reported needs to be tracked to avoid regressions. In this case the QA Teams needs also incorporate a new test case in the tool to detect them.</p>",

        factorytested: "<h1>Factory Tested</h1><ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Factory Maintainer</li></ul>",

        createiso: "<h1>Create ISO</h1><ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Coordinator</li></ul>",

        factoryiso: "<h1>Factory ISO</h1><ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Factory Maintainer</li></ul>",

        coordinator: "<h1>Coordinator</h1>",
        factorymaintainer: "<h1>Factory Maintainer</h1>",
        legalreviewer: "<h1>Legal Reviewer</h1>",
        securityreviewer: "<h1>Security Reviewer</h1>",
        technicalreviewer: "<h1>Technical Reviewer</h1>",
        qateam: "<h1>QA Team</h1>",
        projectmaintainer: "<h1>Project Maintainer</h1>",
        packagemaintainer: "<h1>Package Maintainer</h1>",
x:""
      };

      $(document).ready(function() {
        d3.xml("factory.svg", "image/svg+xml", function(xml) {
          svg = document.getElementById("flowchart").appendChild(xml.documentElement);
          $('svg').svgPan('viewport', true, true, false, 1.5 );

          $("#viewport g").click(function() {
            if (description.hasOwnProperty($(this).attr("id"))) {
              $("#description").hide();
              $("#description").html(description[$(this).attr("id")]);
              $("#description").fadeIn();
            }
          });
        });
      });
    </script>
  </body>
</html>
