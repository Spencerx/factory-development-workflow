window.dialog = function(title, content) {
  if ($("#dialog").is(":visible")) {
    $("#dialog").html(content);
    $("span.ui-dialog-title").html(title);
  } else {
    $("#dialog").remove();
    $("body").append("<div id=\"dialog\" title=\"" + title + "\">\n" + content + "</div>");
    $("#dialog").dialog({width: 500});
  }
}

window.titles = {
  // Actions and conditions
  packagedevel: "Package development",
  createsr: "Create SR",
  acceptsr: "Accept Submit Request",
  develprojectint: "Devel Project Integration",
  createsrfactory: "Create SR to Factory",
  autolegal: "Auto Legal",
  rpmlint: "rpmlint",
  checkrepo: "Repo Checker",
  needsstaging: "Needs Staging",
  stagingprojectint: "Staging Project Integration",
  createsrgroup: "Create SR Groups",
  mergedevel: "Merge in Devel Project",
  needsqa: "Needs QA",
  preinttest: "Pre Integration Test",
  legalreview: "Legal Review",
  rpmlint2: "rpmlint",
  technicalrev: "Technical Review",
  acceptsr2: "Accept Submit Request",
  factoryint: "Factory Integration",
  integrationtest: "Integration Test",
  bugreport: "Bug Report",
  factorytested: "Factory Tested",
  createiso: "Create ISO",
  factoryiso: "Factory ISO",
  // Roles
  coordinator: "Coordinator",
  factorymaintainer: "Factory Maintainer",
  legalreviewer: "Legal Reviewer",
  securityreviewer: "Security Reviewer",
  technicalreviewer: "Technical Reviewer",
  qateam: "QA Team",
  projectmaintainer: "Project Maintainer",
  packagemaintainer: "Package Maintainer"
}

window.descriptions = {
  packagedevel: "<ul><li><strong>Type:</strong> Starting Point. Action</li><li><strong>Role:</strong> Package Maintainer</li></ul><p>A package is usually developed in a Home Project. We can consider it is the starting poing for this workflow, together with the Devel Project Integration task.</p><p>With the OBS, a contributor can make a local branch (usually from a Devel Project) of the package to start working on it. Once the developer finish with the package, he creates a Submit Request before to send it back.</p>This is usually how packages are being developed: They start in home project, move to devel project and continue to Factory.</p>",

  createsr: "<ul><li><strong>Type:</strong>Action</li><li><strong>Role:</strong> Package Maintainer</li></ul><p>A Submit Request is a request of integration from one project to another. This object also capture all the changes made in the package, with some of the meta information related with this petition (history of approvals, current status, etc).</p><p>If the developer want to include the updated version of the package, she / he needs to create a formal petition via this SR. We also have policies that describe what extra actions needs to be done when the developer want to add a new package to Factory.</p>",

  acceptsr: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>The Project Maintainer can decide to accept or reject the SR according to technical decisions.</p><p>This decision is expressed via OBS and usually the rejection is justified to the original developer, in order to give to her / him a new chance to resubmit the package.</p>",

  develprojectint: "<ul><li><strong>Type:</strong> Starting Point. Action</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>The integration can be defined as the process of merging all packages together in a single tree, creating a consistent whole inside the Devel Project.</p><p>This integration can have two different origins: <ol><li>when the Project Maintainer is working in his own project (in this case this action can be considered as a starting point</li><li>as a result of the integration of the SR generated by an external contributor.</li></ol></p><p>The Package Maintainer also can work on her / his own package without the Project Maintainer intervention.</p>",

  createsrfactory: "<ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>Create the SR (or group of SR) to be integrated into Factory.</p>",

  autolegal: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Legal Reviewer (Bot)</li></ul><p>The osc-legal.py bot check if the package referenced in the SR had a compatible license or if this package was previously approved. If none of these conditions are met, the bot can reject the SR and wait for a manual review later in the process.</p>",

  rpmlint: "<ul><li><strong>Type:</strong> Condition</li> \
	  <li><strong>Role:</strong> Security Reviewer (Bot)</li> \
	  </ul><p>rpmlint runs as part of the package build. The review bot makes sure \
	  that there are no overrides of rpmlint rules that bypass policy</p>",

  checkrepo: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Technical Reviewer (Bot)</li></ul><p>There is an automatic technical review process for every new SR to Factory. This review checks for potential problems before the integration, like expanding the Base:System, disabled repositories, new version of the packages or introducing cycles in the dependencies</p>",

  needsstaging: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Technical Reviewer</li></ul><p>Some packages (or groups of packages) need more effort to be integrated into Factory. For example, a new update of GCC can demand some work to another packages that do not compile using the new compiler without modification.</p><p>For those packages is a good idea to 'fork' Factory, integrating an initial version of the new package together with the all affected packages. Now the developers can work on the integration of all those components. This is the main reason of the staging project.</p><p>But someone needs to make a decision about the kind of projects that needs a staging project, because the creation of a staging project from scratch is expensive. To avoid the waste of resources, one possible solution is creating a pool of staging projects that can be assigned and prepared by the Technical Reviewer. In case of necessity the Factory Maintainer can create new staging projects.</p>",

  stagingprojectint: "<ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>Staging Projects is one of the most important changes proposed for the new workflow. Staging project is assigned by the Technical Reviewer for packages that can affect multiple other packages. For example: GCC, Autotools, systemd or maybe NetworkManager are good candidates for a Staging Project.</p><p>So, they start as a submission to Factory that is deemed to require a Staging Project, or that they are part ot already existing request. The Staging Project have a single maintainer (similar to a Project Maintainer) and multiple developers or contributors. The contributors can create SR to this Staging Project, but only the Project Maintainer can create the SR that goes outside the Staging Project.</p><p>The Staging Project is developed on a specific branch of openSUSE:Factory, and is used to fix the issues related with this package.</p>",

  createsrgroup: "<ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>The Project Maintainer for this Staging Project is the only one that can create a group of SR to Factory (or, as we will see, to comeback to the Devel Project). The group of SR needs to be managed as a transactional unit: is accepted or rejected as a whole. This transactional nature avoid problems related with changes that only have meaning when are grouped all together.</p>",

  mergedevel: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Project Maintainer</li></ul><p>Some SR from the Staging Project can continue the path to Factory, but some of the changes can comeback to the Devel Project (or group of Devel Projects). The rationale behind this is to avoid (or at least mitigate) the so called 'merge problem'. This problems happens when the version of the package that we found in Factory in not exactly the one that was sent in the original SR from the Devel Project, and the version of the Devel Project was updated after the SR (but before the integration into Factory). If you are a Project Maintainer or a Package Maintainer you know what I mean with this: there is not a clear way in OBS to make a merge different from a fast-forward one.</p>",

  needsqa: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Technical Reviewer</li></ul><p>There are some packages, like the Linux kernel, that are good candidates for automatic testing before the integration into Factory. Good candidates are packages that can put the system in a very unreliable situation (for example, they can't boot anymore or can disable the access to the network).</p><p>In this task the Technical Reviewer need to identify such packages in order to demand a pre integration test from the QA Team.</p>",

  preinttest: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> QA Team</li></ul><p>Process to check whether is safe enough to integrate a set of changes into Factory. We plan to update openQA and make a more stable tool that can help the QA team to automatize this king of pre-Integration tests. With this task we can discard bad updates that can compromise the full system, and guarantee that at least what is in Factory can provide a minimum functionality to the user.</p>",

  legalreview: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Legal Reviewer</li></ul><p>During the legal review the package which didn't pass the automatic checks is inspected by legal reviewer.It is verified that proclaimed licence match the code, it is distributable and there are no infringements or patents involved.</p>",

  rpmlint2: "<ul><li><strong>Type:</strong> Condition</li> \
	  <li><strong>Role:</strong> Security Reviewer</li> \
	  </ul><p>rpmlint runs as part of the package build. The \
          review bot makes sure \ that there are no overrides of \
          rpmlint rules that bypass policy. If there is any problem, \
          the Security Reviewer can help to the developer to review \
          manually the package and provide advice to fix the policy \
	  violation.</p>",

  technicalrev: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Technical Reviewer</li></ul><p>Technical review is formal verification that the submission is up-par with regards to all the formatting norms for changelog and spec files.</p><p>During the review the code is also verified not to contain any unforseen consequences.</p>",

  acceptsr2: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Factory Maintainer</li></ul><p>The process of merging all packages together in a single tree, creating a consistent whole in Factory. The right time for integration needs to be planned based of availability of resources to keep the performance of the overall building process within acceptable parameters.</p>",

  factoryint: "<ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Factory Maintainer</li></ul><p>Continuous process to ensure that Factory is solid enough to be used in a daily basis by contributors and for creating Factory-Tested and the ISOs. The process includes periodical checks of the overall Factory status, reverting or removing packages causing troubles, notifying issues with packages to the responsible people, maintaining the XML files used to generate ISO images and the patterns needed for installation and other related tasks.</p>",

  integrationtest: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> QA Team</li></ul><p>Integration tests are done by QA Team when a new SR is integrated in Factory and need to be tested before pass to Factory-Tested. When the Factory Maintainer integrates a new SR, there is a good possibility that some part of the system stop working. The Integration Test is designed to assure that the integration of a new package doesn't affect the functionality of a different package in a unnoticed way.</p><p>To provide this, QA Team will run a set of transversal tests along the full distribution, to make sure that the system work in a similar way previous the integration step.</p><p>This task also decides if the new SR that comes from Factory go to the next step until Factory-Tested. If QA Team detect an important issue related with the new SR, they can decline the copy of the new package (or group of packages) to Factory-Tested.</p>",

  bugreport: "<ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> QA Team</li></ul><p>The Integration Test task can detect errors in the distribution, and as a result of that QA Team needs to fill a bug report. This bug report needs to be precise and detailed to make easy the work for the developer.</p><p>Sometimes the bug reported needs to be tracked to avoid regressions. In this case the QA Teams needs also incorporate a new test case in the tool to detect them.</p>",

  factorytested: "<ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Factory Maintainer</li></ul><p>The final product for the users. It is the expected version that they will use if they want to use the Factory.</p><p>Of course if they wish, they can use the more bleeding edge version of Factory marked here as integration.</p>",

  createiso: "<ul><li><strong>Type:</strong> Condition</li><li><strong>Role:</strong> Coordinator</li></ul><p>From time to time the Coordinator can decide if the quality of the installation part of Factory is good enought to make an ISO snapshot of the distribution.</p><p>This image will be the recommended medium to install the distribution.</p>",

  factoryiso: "<ul><li><strong>Type:</strong> Action</li><li><strong>Role:</strong> Factory Maintainer</li></ul><p>Factory snapshot used to install the distribution.</p>",

  coordinator: "<ul><li><strong>Type:</strong> Role</li><li><strong>Current role:</strong> Release Manager</li></ul><p>The person for this role will be one individual selected from the <strong>Factory maintainer</strong> role.</p><p>Previously this role was more broad and with more tasks. But due to the automation in place the Coordinator will be just responsible for reviewing the ISO after all previous steps were completed.</p>",

  factorymaintainer: "<ul><li><strong>Type:</strong> Role</li><li><strong>Current role:</strong> Factory maintainers</li></ul><p><ul><li>Does final review and merge to Factory integration project.</li><li>Has access to all devel projects in order to make sure needed changes are done.</li><li>Does keep in mind overall state of Factory state and merge according to it.</li></ul></p>",

  legalreviewer: "<ul><li><strong>Type:</strong> Role</li><li><strong>Current role:</strong> Legal team</li></ul><p><ul><li>Checks whether we can legally distribute a package.</li><li>Reviews whether declared license is correct and looks for possible conflicting licenses.</li><li>Checks license changes among packages.</li></ul></p>",

  securityreviewer: "<ul><li><strong>Type:</strong> Role</li><li><strong>Current role:</strong> Security team</li></ul><p><ul><li>Reviews packages for special privileges (suid, capabilities, dbus, ...). No package with that requires extra privileges can be included in Factory without security review.</li><li>Reports possible security issues.</li><li>Introduces new policies to harden the distribution.</li></ul></p>",

  technicalreviewer: "<ul><li><strong>Type:</strong> Role</li><li><strong>Role:</strong>Technical Reviewer</li><li><strong>Current role:</strong> Technical Reviewer</li></ul><p>Reviews submissions to the Factory to make sure they follow packaging guidelines and doesn't contain obvious errors.</p><p>Newly technical reviewer also groups packages related to each other (think new KDE) that are going to get accepted all together.</p><p>He/she also decides, when the change might have a big enough impact to run it through staging project first (new autotools, boost, gcc, icu, ...) or when the change is big and might seriously broke things for people in runtime so it needs openQA run (think new Xorg, new systemd, ...)",

  qateam: "<ul><li><strong>Type:</strong> Role</li><li><strong>Role:</strong>QA Team</li><li><strong>Current role:</strong> none</li></ul><p>Team of people who watch over automatic tests and try to maintain them and adjust them whenever needed.</p><p>This team is working on expanding openQA and its coverage.</p>",

  projectmaintainer: "<ul><li><strong>Type:</strong> Role</li><li><strong>Role:</strong>Project maintainer</li><li><strong>Current role:</strong> Project Maintainer</li></ul><p>Reviewer of submissions to the devel project and pushes them forward when needed. Almost always also package maintainer.</p><p>Project maintainer can be also maintainer of temporal staging project that gets created when some major change is on way to factory. Here he has to fix packages/ping package maintainer to fix packages and propagate them back to the devel project.</p>",

  packagemaintainer: "<ul><li><strong>Type:</strong> Role</li><li><strong>Role:</strong>Package maintainer</li><li><strong>Current role:</strong> Package Maintainer</li></ul><p>Somebody who creates, fixes or changes individual package, probably will overlap with project maintainer in quite some cases.</p>"
}

window.explain = function(id) {
  if (descriptions.hasOwnProperty(id)) {
    dialog(titles[id], descriptions[id]);
  }
  return true;
}
